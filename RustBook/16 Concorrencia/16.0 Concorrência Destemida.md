# Concorrência Destemida

Lidar com programação concorrente de forma segura e eficiente é outro dos principais objetivos do Rust. *Programação concorrente*, onde diferentes partes de um programa são executadas independentemente, e *programação paralela*, onde diferentes partes de um programa são executadas ao mesmo tempo, estão se tornando cada vez mais importantes à medida que mais computadores aproveitam seus múltiplos processadores. Historicamente, programar nesses contextos tem sido difícil e propenso a erros: o Rust espera mudar isso.

Inicialmente, a equipe do Rust pensou que garantir a segurança da memória e evitar problemas de concorrência eram dois desafios separados a serem resolvidos com métodos diferentes. Com o tempo, a equipe descobriu que os sistemas de propriedade e tipo são um poderoso conjunto de ferramentas para ajudar a gerenciar a segurança da memória *e* problemas de concorrência! Ao aproveitar a verificação de propriedade e tipo, muitos erros de concorrência são erros de tempo de compilação no Rust, em vez de erros de tempo de execução. Portanto, em vez de fazer você gastar muito tempo tentando reproduzir as circunstâncias exatas em que um bug de concorrência em tempo de execução ocorre, o código incorreto se recusará a compilar e apresentará um erro explicando o problema. Como resultado, você pode corrigir seu código enquanto está trabalhando nele, em vez de potencialmente depois que ele foi enviado para produção. Apelidamos esse aspecto do Rust de *concorrência* *destemida*. A concorrência destemida permite que você escreva código livre de bugs sutis e fácil de refatorar sem introduzir novos bugs.

Nota: Para simplificar, vamos nos referir a muitos dos problemas como *concorrentes*, em vez de sermos mais precisos dizendo *concorrentes e/ou paralelos*. Se este livro fosse sobre concorrência e/ou paralelismo, seríamos mais específicos. Para este capítulo, substitua mentalmente *concorrente e/ou paralelo* sempre que usarmos *concorrente*.

Muitas linguagens são dogmáticas sobre as soluções que oferecem para lidar com problemas concorrentes. Por exemplo, Erlang tem funcionalidade elegante para concorrência de passagem de mensagens, mas tem apenas maneiras obscuras de compartilhar estado entre threads. Suportar apenas um subconjunto de soluções possíveis é uma estratégia razoável para linguagens de nível superior, porque uma linguagem de nível superior promete benefícios ao abrir mão de algum controle para obter abstrações. No entanto, espera-se que as linguagens de nível inferior forneçam a solução com o melhor desempenho em qualquer situação e tenham menos abstrações sobre o hardware. Portanto, o Rust oferece uma variedade de ferramentas para modelar problemas da maneira que for apropriada para sua situação e requisitos.

Aqui estão os tópicos que abordaremos neste capítulo:

*   Como criar threads para executar vários trechos de código ao mesmo tempo
*   Concorrência de *passagem de mensagens*, onde canais enviam mensagens entre threads
*   Concorrência de *estado compartilhado*, onde várias threads têm acesso a algum dado
*   As traits `Sync` e `Send`, que estendem as garantias de concorrência do Rust para tipos definidos pelo usuário, bem como tipos fornecidos pela biblioteca padrão