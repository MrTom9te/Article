# Trabalhando com Qualquer Número de Futures

Quando mudamos de usar duas futures para três na seção anterior, também tivemos que mudar de usar `join` para usar `join3`. Seria incômodo ter que chamar uma função diferente toda vez que mudássemos o número de futures que queríamos juntar. Felizmente, temos uma forma macro de `join` para a qual podemos passar um número arbitrário de argumentos. Ela também lida com a espera das futures por si mesma. Assim, podemos reescrever o código da Listagem 17-13 para usar `join!` em vez de `join3`, como na Listagem 17-14.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::time::Duration;

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("oi"),
                String::from("do"),
                String::from("futuro"),
                String::from("distante"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("recebido '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("mais"),
                String::from("mensagens"),
                String::from("para"),
                String::from("você"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        trpl::join!(tx1_fut, tx_fut, rx_fut);
    });
}
```

Listagem 17-14: Usando `join!` para esperar por múltiplas futures

Isso é definitivamente uma melhoria em relação a alternar entre `join` e `join3` e `join4` e assim por diante! No entanto, mesmo esta forma de macro só funciona quando conhecemos o número de futures antecipadamente. No Rust do mundo real, porém, colocar futures em uma coleção e depois esperar que algumas ou todas as futures delas sejam concluídas é um padrão comum.

Para verificar todas as futures em alguma coleção, precisaremos iterar sobre elas e juntar _todas_ elas. A função `trpl::join_all` aceita qualquer tipo que implementa a trait `Iterator`, que você aprendeu em "A Trait Iterator e o Método `next`" no Capítulo 13, então parece ser exatamente o que precisamos. Vamos tentar colocar nossas futures em um vetor e substituir `join!` por `join_all`, como mostrado na Listagem 17-15.

```rust
extern crate trpl; // necessário para mdbook test

use std::time::Duration;

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("oi"),
                String::from("do"),
                String::from("futuro"),
                String::from("distante"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("recebido '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("mais"),
                String::from("mensagens"),
                String::from("para"),
                String::from("você"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
    });
}
```

Listagem 17-15: Armazenando futures anônimas em um vetor e chamando `join_all`

Infelizmente, este código não compila. Em vez disso, obtemos este erro:

```
error[E0308]: mismatched types
  --> src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a 
different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
```

Isso pode ser surpreendente. Afinal, nenhum dos blocos async retorna nada, então cada um produz uma `Future<Output = ()>`. Lembre-se que `Future` é uma trait, porém, e que o compilador cria um enum único para cada bloco async. Você não pode colocar duas estruturas escritas manualmente diferentes em um `Vec`, e a mesma regra se aplica aos diferentes enums gerados pelo compilador.

Para fazer isso funcionar, precisamos usar _objetos trait_, assim como fizemos em "Retornando Erros da Função run" no Capítulo 12. (Cobriremos objetos trait em detalhes no Capítulo 18.) Usar objetos trait nos permite tratar cada uma das futures anônimas produzidas por esses tipos como sendo do mesmo tipo, porque todas elas implementam a trait `Future`.

> Nota: Na seção "Usando um Enum para Armazenar Múltiplos Valores" do Capítulo 8, discutimos outra maneira de incluir múltiplos tipos em um `Vec`: usando um enum para representar cada tipo que pode aparecer no vetor. Não podemos fazer isso aqui, entretanto. Por um lado, não temos como nomear os diferentes tipos, porque eles são anônimos. Por outro, a razão pela qual recorremos a um vetor e `join_all` em primeiro lugar foi para poder trabalhar com uma coleção dinâmica de futures onde só nos importamos que elas tenham o mesmo tipo de saída.

Começamos envolvendo cada future no `vec!` em um `Box::new`, como mostrado na Listagem 17-16.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::time::Duration;

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("oi"),
                String::from("do"),
                String::from("futuro"),
                String::from("distante"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("recebido '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("mais"),
                String::from("mensagens"),
                String::from("para"),
                String::from("você"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
    });
}
```

Listagem 17-16: Usando `Box::new` para alinhar os tipos das futures em um `Vec`

Infelizmente, este código ainda não compila. Na verdade, obtemos o mesmo erro básico que tivemos antes para a segunda e terceira chamadas `Box::new`, além de novos erros referindo-se à trait `Unpin`. Voltaremos aos erros de `Unpin` em um momento. Primeiro, vamos corrigir os erros de tipo nas chamadas `Box::new` anotando explicitamente o tipo da variável `futures` (veja a Listagem 17-17).

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{future::Future, time::Duration};

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("oi"),
                String::from("do"),
                String::from("futuro"),
                String::from("distante"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("recebido '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("mais"),
                String::from("mensagens"),
                String::from("para"),
                String::from("você"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let futures: Vec<Box<dyn Future<Output = ()>>> =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
    });
}
```

Listagem 17-17: Corrigindo o restante dos erros de incompatibilidade de tipo usando uma declaração de tipo explícita

Esta declaração de tipo é um pouco complicada, então vamos analisá-la:
- O tipo mais interno é a própria future. Observamos explicitamente que a saída da future é o tipo unitário `()` escrevendo `Future<Output = ()>`.
- Em seguida, anotamos a trait com `dyn` para marcá-la como dinâmica.
- A referência à trait inteira é envolvida em um `Box`.
- Finalmente, declaramos explicitamente que `futures` é um `Vec` contendo esses itens.

Isso já fez uma grande diferença. Agora, quando executamos o compilador, obtemos apenas os erros mencionando `Unpin`. Embora existam três deles, seus conteúdos são muito semelhantes.

```
error[E0308]: mismatched types
   --> src/main.rs:46:46
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
24  |         let rx_fut = async {
    |                      ----- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                     -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                     |
    |                                     arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:24:22: 24:27}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -> Self {
    |            ^^^

error[E0308]: mismatched types
   --> src/main.rs:46:64
    |
10  |         let tx1_fut = async move {
    |                       ---------- the expected `async` block
...
30  |         let tx_fut = async move {
    |                      ---------- the found `async` block
...
46  |             vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
    |                                                       -------- ^^^^^^ expected `async` block, found a different `async` block
    |                                                       |
    |                                                       arguments to this function are incorrect
    |
    = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
               found `async` block `{async block@src/main.rs:30:22: 30:32}`
    = note: no two async blocks, even if identical, have the same type
    = help: consider pinning your async block and casting it to a trait object
note: associated function defined here
   --> file:///home/.rustup/toolchains/1.82/lib/rustlib/src/rust/library/alloc/src/boxed.rs:255:12
    |
255 |     pub fn new(x: T) -> Self {
    |            ^^^

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
   --> src/main.rs:48:24
    |
48  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box<{async block@src/main.rs:10:23: 10:33}>: Future`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to implement `Future`
note: required by a bound in `join_all`
   --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all<I>(iter: I) -> JoinAll<I::Item>
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --> src/main.rs:48:9
   |
48 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box<{async block@src/main.rs:10:23: 10:33}>: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll<F>
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --> src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`, which is required by `Box<{async block@src/main.rs:10:23: 10:33}>: Future`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --> file:///home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll<F>
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
```

Isso é _muito_ para digerir, então vamos separá-lo. A primeira parte da mensagem nos diz que o primeiro bloco async (`src/main.rs:8:23: 20:10`) não implementa a trait `Unpin` e sugere usar `pin!` ou `Box::pin` para resolvê-lo. Mais adiante no capítulo, exploraremos mais alguns detalhes sobre `Pin` e `Unpin`. Por enquanto, porém, podemos apenas seguir o conselho do compilador para resolver o problema. Na Listagem 17-18, começamos atualizando a anotação de tipo para `futures`, com um `Pin` envolvendo cada `Box`. Em segundo lugar, usamos `Box::pin` para fixar as próprias futures.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{
    future::Future,
    pin::{pin, Pin},
    time::Duration,
};

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = pin!(async move {
            let vals = vec![
                String::from("oi"),
                String::from("do"),
                String::from("futuro"),
                String::from("distante"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        });

        let rx_fut = pin!(async {
            while let Some(value) = rx.recv().await {
                println!("recebido '{value}'");
            }
        });

        let tx_fut = pin!(async move {
            let vals = vec![
                String::from("mais"),
                String::from("mensagens"),
                String::from("para"),
                String::from("você"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        });

        let futures: Vec<Pin<Box<dyn Future<Output = ()>>>> =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];

        trpl::join_all(futures).await;
    });
}
```

Listagem 17-18: Usando `Pin` e `Box::pin` para fazer o `Vec` verificar o tipo

Se compilarmos e executarmos isso, finalmente obteremos a saída que esperávamos:

```
recebido 'oi'
recebido 'mais'
recebido 'do'
recebido 'mensagens'
recebido 'futuro'
recebido 'para'
recebido 'distante'
recebido 'você'
```

Ufa!

Há um pouco mais para explorar aqui. Por um lado, usar `Pin<Box<T>>` adiciona uma pequena sobrecarga ao colocar essas futures no heap com `Box` - e estamos fazendo isso apenas para alinhar os tipos. Na verdade, não _precisamos_ da alocação de heap, afinal: essas futures são locais para esta função específica. Como observado anteriormente, `Pin` é em si um tipo wrapper, então podemos obter o benefício de ter um único tipo no `Vec` - a razão original pela qual usamos `Box` - sem fazer uma alocação de heap. Podemos usar `Pin` diretamente com cada future, usando a macro `std::pin::pin`.

No entanto, ainda devemos ser explícitos sobre o tipo da referência fixada; caso contrário, Rust ainda não saberá como interpretar estes como objetos de trait dinâmicos, que é o que precisamos que eles sejam no `Vec`. Portanto, usamos `pin!` para cada future quando a definimos, e definimos `futures` como um `Vec` contendo referências mutáveis fixadas para o tipo de future dinâmica, como na Listagem 17-19.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{
    future::Future,
    pin::{pin, Pin},
    time::Duration,
};

fn main() {
    trpl::run(async {
        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = pin!(async move {
            // --snip--
            let vals = vec![
                String::from("oi"),
                String::from("do"),
                String::from("futuro"),
                String::from("distante"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        });

        let rx_fut = pin!(async {
            // --snip--
            while let Some(value) = rx.recv().await {
                println!("recebido '{value}'");
            }
        });

        let tx_fut = pin!(async move {
            // --snip--
            let vals = vec![
                String::from("mais"),
                String::from("mensagens"),
                String::from("para"),
                String::from("você"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        });

        let futures: Vec<Pin<&mut dyn Future<Output = ()>>> =
            vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
    });
}
```

Listagem 17-19: Usando `Pin` diretamente com a macro `pin!` para evitar alocações de heap desnecessárias

Chegamos até aqui ignorando o fato de que poderíamos ter diferentes tipos de `Output`. Por exemplo, na Listagem 17-20, a future anônima para `a` implementa `Future<Output = u32>`, a future anônima para `b` implementa `Future<Output = &str>`, e a future anônima para `c` implementa `Future<Output = bool>`.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

fn main() {
    trpl::run(async {
        let a = async { 1u32 };
        let b = async { "Olá!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
    });
}
```

Listagem 17-20: Três futures com tipos distintos

Podemos usar `trpl::join!` para aguardá-las, porque ele nos permite passar vários tipos de future e produz uma tupla desses tipos. Nós _não podemos_ usar `trpl::join_all`, porque ele exige que todas as futures passadas tenham o mesmo tipo. Lembre-se, esse erro foi o que nos levou a iniciar esta aventura com `Pin`!

Este é um compromisso fundamental: podemos lidar com um número dinâmico de futures com `join_all`, desde que todas tenham o mesmo tipo, ou podemos lidar com um conjunto fixo de futures com as funções `join` ou a macro `join!`, mesmo que tenham tipos diferentes. Este é o mesmo cenário que enfrentaríamos ao trabalhar com quaisquer outros tipos em Rust. As futures não são especiais, mesmo que tenhamos uma sintaxe agradável para trabalhar com elas, e isso é algo bom.

## Competindo Futures

Quando "juntamos" futures com a família de funções e macros `join`, exigimos que _todas_ elas terminem antes de prosseguirmos. Às vezes, porém, precisamos apenas que _alguma_ future de um conjunto termine antes de prosseguirmos - algo semelhante a competir uma future contra outra.

Na Listagem 17-21, usamos novamente `trpl::race` para executar duas futures, `slow` e `fast`, uma contra a outra.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::time::Duration;

fn main() {
    trpl::run(async {
        let slow = async {
            println!("'slow' iniciada.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finalizada.");
        };

        let fast = async {
            println!("'fast' iniciada.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finalizada.");
        };

        trpl::race(slow, fast).await;
    });
}
```

Listagem 17-21: Usando `race` para obter o resultado de qualquer future que terminar primeiro

Cada future imprime uma mensagem quando começa a ser executada, pausa por algum tempo chamando e aguardando `sleep`, e então imprime outra mensagem quando termina. Em seguida, passamos `slow` e `fast` para `trpl::race` e esperamos que uma delas termine. (O resultado aqui não é muito surpreendente: `fast` vence.) Ao contrário de quando usamos `race` em "Nosso Primeiro Programa Async", apenas ignoramos a instância `Either` que ele retorna aqui, porque todo o comportamento interessante acontece no corpo dos blocos async.

Observe que, se você inverter a ordem dos argumentos para `race`, a ordem das mensagens "iniciada" muda, mesmo que a future `fast` sempre complete primeiro. Isso ocorre porque a implementação desta função `race` em particular não é justa. Ela sempre executa as futures passadas como argumentos na ordem em que são passadas. Outras implementações _são_ justas e escolherão aleatoriamente qual future sondar primeiro. Independentemente de a implementação de `race` que estamos usando ser justa ou não, _uma_ das futures será executada até o primeiro `await` em seu corpo antes que outra tarefa possa começar.

Lembre-se de "Nosso Primeiro Programa Async" que, em cada ponto de await, o Rust dá a um runtime a chance de pausar a tarefa e mudar para outra se a future que está sendo aguardada não estiver pronta. O inverso também é verdadeiro: Rust _só_ pausa blocos async e devolve o controle a um runtime em um ponto de await. Tudo entre pontos de await é síncrono.

Isso significa que, se você fizer um monte de trabalho em um bloco async sem um ponto de await, essa future bloqueará qualquer outra future de fazer progresso. Você pode ouvir isso sendo referido como uma future _privando_ outras futures. Em alguns casos, isso pode não ser um grande problema. No entanto, se você estiver fazendo algum tipo de configuração cara ou trabalho de longa duração, ou se tiver uma future que continuará fazendo alguma tarefa específica indefinidamente, você precisará pensar quando e onde devolver o controle ao runtime.

Da mesma forma, se você tiver operações bloqueantes de longa duração, async pode ser uma ferramenta útil para fornecer maneiras para diferentes partes do programa se relacionarem entre si.

Mas _como_ você devolveria o controle ao runtime nesses casos?

## Cedendo o Controle ao Runtime

Vamos simular uma operação de longa duração. A Listagem 17-22 introduz uma função `slow`.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{thread, time::Duration};

fn main() {
    trpl::run(async {
        // Chamaremos `slow` aqui mais tarde
    });
}

fn slow(name: &str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' executou por {ms}ms");
}
```

Listagem 17-22: Usando `thread::sleep` para simular operações lentas

Este código usa `std::thread::sleep` em vez de `trpl::sleep` para que chamar `slow` bloqueie a thread atual por alguns milissegundos. Podemos usar `slow` para representar operações do mundo real que são longas e bloqueantes.

Na Listagem 17-23, usamos `slow` para emular a realização desse tipo de trabalho vinculado à CPU em um par de futures.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{thread, time::Duration};

fn main() {
    trpl::run(async {
        let a = async {
            println!("'a' iniciada.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finalizada.");
        };

        let b = async {
            println!("'b' iniciada.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finalizada.");
        };

        trpl::race(a, b).await;
    });
}

fn slow(name: &str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' executou por {ms}ms");
}
```

Listagem 17-23: Usando `thread::sleep` para simular operações lentas

Para começar, cada future só devolve o controle ao runtime _após_ realizar um monte de operações lentas. Se você executar este código, verá esta saída:
```
'a' iniciada.
'a' executou por 30ms
'a' executou por 10ms
'a' executou por 20ms
'b' iniciada.
'b' executou por 75ms
'b' executou por 10ms
'b' executou por 15ms
'b' executou por 350ms
'a' finalizada.
```

Assim como em nosso exemplo anterior, `race` ainda termina assim que `a` é concluída. No entanto, não há intercalação entre as duas futures. A future `a` faz todo o seu trabalho até a chamada `trpl::sleep` ser aguardada, então a future `b` faz todo o seu trabalho até sua própria chamada `trpl::sleep` ser aguardada, e finalmente a future `a` completa. Para permitir que ambas as futures façam progresso entre suas tarefas lentas, precisamos de pontos de await para podermos devolver o controle ao runtime. Isso significa que precisamos de algo que possamos aguardar!

Já podemos ver esse tipo de transferência acontecendo na Listagem 17-23: se removêssemos o `trpl::sleep` no final da future `a`, ela seria concluída sem que a future `b` executasse _de forma alguma_. Vamos tentar usar a função `sleep` como ponto de partida para permitir que as operações alternem o progresso, como mostrado na Listagem 17-24.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{thread, time::Duration};

fn main() {
    trpl::run(async {
        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' iniciada.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finalizada.");
        };

        let b = async {
            println!("'b' iniciada.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 35);
            trpl::sleep(one_ms).await;
            println!("'b' finalizada.");
        };

        trpl::race(a, b).await;
    });
}

fn slow(name: &str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' executou por {ms}ms");
}
```

Listagem 17-24: Usando `sleep` para permitir que operações alternem o progresso

Na Listagem 17-24, adicionamos chamadas `trpl::sleep` com pontos de await entre cada chamada a `slow`. Agora o trabalho das duas futures é intercalado:

```
'a' iniciada.
'a' executou por 30ms
'b' iniciada.
'b' executou por 75ms
'a' executou por 10ms
'b' executou por 10ms
'a' executou por 20ms
'b' executou por 15ms
'a' finalizada.
```

A future `a` ainda executa um pouco antes de transferir o controle para `b`, porque ela chama `slow` antes de chamar `trpl::sleep`, mas depois disso as futures alternam cada vez que uma delas atinge um ponto de await. Neste caso, fizemos isso após cada chamada para `slow`, mas poderíamos dividir o trabalho da maneira que fizesse mais sentido para nós.

No entanto, não queremos realmente _dormir_ aqui: queremos fazer progresso o mais rápido possível. Só precisamos devolver o controle ao runtime. Podemos fazer isso diretamente, usando a função `yield_now`. Na Listagem 17-25, substituímos todas as chamadas `sleep` por `yield_now`.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{thread, time::Duration};

fn main() {
    trpl::run(async {
        let a = async {
            println!("'a' iniciada.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finalizada.");
        };

        let b = async {
            println!("'b' iniciada.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 35);
            trpl::yield_now().await;
            println!("'b' finalizada.");
        };

        trpl::race(a, b).await;
    });
}

fn slow(name: &str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' executou por {ms}ms");
}
```

Listagem 17-25: Usando `yield_now` para permitir que operações alternem o progresso

Este código é mais claro sobre a intenção real e pode ser significativamente mais rápido do que usar `sleep`, porque temporizadores como o usado por `sleep` geralmente têm limites sobre quão granulares podem ser. A versão de `sleep` que estamos usando, por exemplo, sempre dormirá por pelo menos um milissegundo, mesmo se passarmos uma `Duration` de um nanossegundo. Novamente, computadores modernos são _rápidos_: eles podem fazer muito em um milissegundo!

Você pode ver isso por si mesmo configurando um pequeno benchmark, como o da Listagem 17-26. (Esta não é uma maneira especialmente rigorosa de fazer testes de desempenho, mas é suficiente para mostrar a diferença aqui.)

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::time::{Duration, Instant};

fn main() {
    trpl::run(async {
        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "Versão 'sleep' terminou após {} segundos.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "Versão 'yield' terminou após {} segundos.",
            time.as_secs_f32()
        );
    });
}
```

Listagem 17-26: Comparando o desempenho de `sleep` e `yield_now`

Aqui, pulamos toda a impressão de status, passamos uma `Duration` de um nanossegundo para `trpl::sleep` e deixamos cada future ser executada por si só, sem alternar entre as futures. Em seguida, executamos por 1.000 iterações e vemos quanto tempo a future usando `trpl::sleep` leva em comparação com a future usando `trpl::yield_now`.

A versão com `yield_now` é _muito_ mais rápida!

Isso significa que async pode ser útil mesmo para tarefas vinculadas à computação, dependendo do que mais seu programa está fazendo, porque fornece uma ferramenta útil para estruturar os relacionamentos entre diferentes partes do programa. Esta é uma forma de _multitarefa cooperativa_, onde cada future tem o poder de determinar quando entrega o controle por meio de pontos de await. Cada future, portanto, também tem a responsabilidade de evitar o bloqueio por muito tempo. Em alguns sistemas operacionais embarcados baseados em Rust, este é o _único_ tipo de multitarefa!

No código do mundo real, você normalmente não alternaria chamadas de funções com pontos de await em todas as linhas, é claro. Embora ceder o controle dessa maneira seja relativamente barato, não é gratuito. Em muitos casos, tentar dividir uma tarefa vinculada à computação pode torná-la significativamente mais lenta, então às vezes é melhor para o desempenho _geral_ deixar uma operação bloquear brevemente. Sempre meça para ver quais são os reais gargalos de desempenho do seu código. A dinâmica subjacente é importante ter em mente, porém, se você _está_ vendo muito trabalho acontecendo em série que esperava que acontecesse concorrentemente!

## Construindo Nossas Próprias Abstrações Async

Também podemos compor futures juntas para criar novos padrões. Por exemplo, podemos construir uma função `timeout` com os blocos de construção async que já temos. Quando terminarmos, o resultado será outro bloco de construção que poderíamos usar para criar abstrações async ainda mais.

A Listagem 17-27 mostra como esperaríamos que este `timeout` funcionasse com uma future lenta.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::time::Duration;

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "Terminei!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) => println!("Sucesso com '{message}'"),
            Err(duration) => {
                println!("Falha após {} segundos", duration.as_secs())
            }
        }
    });
}
```

Listagem 17-27: Usando nosso `timeout` imaginado para executar uma operação lenta com limite de tempo

Vamos implementar isso! Para começar, vamos pensar na API para `timeout`:
- Precisa ser uma função async para que possamos aguardá-la.
- Seu primeiro parâmetro deve ser uma future para executar. Podemos torná-lo genérico para permitir que funcione com qualquer future.
- Seu segundo parâmetro será o tempo máximo de espera. Se usarmos uma `Duration`, isso facilitará o repasse para `trpl::sleep`.
- Deve retornar um `Result`. Se a future completar com sucesso, o `Result` será `Ok` com o valor produzido pela future. Se o timeout expirar primeiro, o `Result` será `Err` com a duração pela qual o timeout esperou.

A Listagem 17-28 mostra esta declaração.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{future::Future, time::Duration};

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finalmente terminado"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) => println!("Sucesso com '{message}'"),
            Err(duration) => {
                println!("Falha após {} segundos", duration.as_secs())
            }
        }
    });
}

async fn timeout<F: Future>(
    future_to_try: F,
    max_time: Duration,
) -> Result<F::Output, Duration> {
    // Aqui é onde nossa implementação vai ficar!
}
```

Listagem 17-28: Definindo a assinatura de `timeout`

Isso satisfaz nossos objetivos para os tipos. Agora vamos pensar sobre o _comportamento_ que precisamos: queremos competir a future passada contra a duração. Podemos usar `trpl::sleep` para fazer uma future de temporizador a partir da duração, e usar `trpl::race` para executar esse temporizador com a future que o chamador passa.

Também sabemos que `race` não é justo, sondando argumentos na ordem em que são passados. Assim, passamos `future_to_try` para `race` primeiro para que ela tenha chance de completar mesmo se `max_time` for uma duração muito curta. Se `future_to_try` terminar primeiro, `race` retornará `Left` com a saída de `future_to_try`. Se `timer` terminar primeiro, `race` retornará `Right` com a saída do temporizador, que é `()`.

Na Listagem 17-29, fazemos correspondência com o resultado de aguardar `trpl::race`.

Nome do arquivo: src/main.rs

```rust
extern crate trpl; // necessário para mdbook test

use std::{future::Future, time::Duration};

use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finalmente terminado"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) => println!("Sucesso com '{message}'"),
            Err(duration) => {
                println!("Falha após {} segundos", duration.as_secs())
            }
        }
    });
}

async fn timeout<F: Future>(
    future_to_try: F,
    max_time: Duration,
) -> Result<F::Output, Duration> {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) => Ok(output),
        Either::Right(_) => Err(max_time),
    }
}
```

Listagem 17-29: Definindo `timeout` com `race` e `sleep`

Se o `future_to_try` for bem-sucedido e obtivermos um `Left(output)`, retornamos `Ok(output)`. Se o temporizador de sleep expirar e obtivermos um `Right(())`, ignoramos o `()` com `_` e retornamos `Err(max_time)`.

Com isso, temos um `timeout` funcional construído a partir de dois outros auxiliares async. Se executarmos nosso código, ele imprimirá o modo de falha após o timeout:

```
Falha após 2 segundos
```

Como as futures compõem com outras futures, você pode construir ferramentas realmente poderosas usando blocos de construção async menores. Por exemplo, você pode usar essa mesma abordagem para combinar timeouts com retentativas e, por sua vez, usá-los com operações como chamadas de rede (um dos exemplos do início do capítulo).

Na prática, você geralmente trabalhará diretamente com `async` e `await`, e secundariamente com funções e macros como `join`, `join_all`, `race` e assim por diante. Você só precisará recorrer a `pin` de vez em quando para usar futures com essas APIs.

Já vimos várias maneiras de trabalhar com múltiplas futures ao mesmo tempo. A seguir, veremos como podemos trabalhar com múltiplas futures em sequência ao longo do tempo com _streams_. Aqui estão mais algumas coisas que você pode querer considerar primeiro:

- Usamos um `Vec` com `join_all` para esperar que todas as futures em algum grupo terminem. Como você poderia usar um `Vec` para processar um grupo de futures em sequência? Quais são os trade-offs de fazer isso?
- Dê uma olhada no tipo `futures::stream::FuturesUnordered` do crate `futures`. Como usá-lo seria diferente de usar um `Vec`? (Não se preocupe com o fato de que ele vem da parte `stream` do crate; ele funciona muito bem com qualquer coleção de futures.)
